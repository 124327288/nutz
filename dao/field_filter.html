<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head><meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=UTF-8"/>
<title>过滤字段</title><link href="../zdoc.css" rel="stylesheet" type="text/css"/>
</head>
<body><a name="top"></a>
<div class="zdoc_header">过滤字段</div>
<div class="zdoc_author"><em>By:</em><b>zozoh</b><a href="mailto:zozohtnt@gmail.com">&lt;zozohtnt@gmail.com&gt;</a></div>
<div class="zdoc_body">
<ul class="zdoc_index_table">
<li>
<div><span class="num">1</span><a href="#为什么需要过滤字段">为什么需要过滤字段</a></div>
</li>
<li>
<div><span class="num">2</span><a href="#如何过滤字段">如何过滤字段</a></div>
</li>
<li>
<div><span class="num">3</span><a href="#字段过滤器的原理">字段过滤器的原理</a></div>
</li>
<li>
<div><span class="num">4</span><a href="#字段过滤器的创建">字段过滤器的创建</a></div>
</li>
<li>
<div><span class="num">5</span><a href="#忽略少数字段">忽略少数字段</a></div>
</li>
<li>
<div><span class="num">6</span><a href="#忽略空值">忽略空值</a></div>
</li>
<li>
<div><span class="num">7</span><a href="#保留几个字段且忽略空值">保留几个字段且忽略空值</a></div>
</li>
<li>
<div><span class="num">8</span><a href="#忽略少数字段且忽略空值">忽略少数字段且忽略空值</a></div>
</li>
<li>
<div><span class="num">9</span><a href="#为多个实体设置字段过滤">为多个实体设置字段过滤</a></div>
</li>
<li>
<div><span class="num">10</span><a href="#使用FieldMatcher创建复杂规则">使用FieldMatcher创建复杂规则</a></div>
</li>
<li>
<div><span class="num">11</span><a href="#无需匿名内部类的写法">无需匿名内部类的写法</a></div>
</li>
</ul>
<div class="hr"><b></b></div>
<h1><a name="为什么需要过滤字段"></a>为什么需要过滤字段</h1>
<div style="float:right;"><a href="#top">Top</a></div>
<p>例如insert时需要忽略某个特定属性, update时只更新某些属性, 查询时需要跳过大字段等。</p>
<p>FieldFilter/FieldMatcher提供细致的过滤选项,包括:</p>
<ul type="disc">
<li>黑名单(locked)</li>
<li>白名单(actived)</li>
<li>忽略空值(ignoreNull)</li>
<li>忽略数值0(ignoreZero)</li>
<li>忽略日期属性(ignoreDate)</li>
<li>忽略空字符串(ignoreBlankStr)</li>
<li>忽略数值型主键(ignoreId), 仅insert操作有效</li>
<li>忽略字符型主键(ignoreName), 仅insert操作有效</li>
<li>忽略复合主键(ignorePk), 仅insert操作有效</li>
</ul>
<p>FieldFilter是FieldMatcher的包装,相当于Map&lt;Class, FieldMatcher&gt;</p>
<p>黑名单和白名单,均为正则表达式,匹配是Java属性名!!</p>
<p>ignoreNull/ignoreZero/ignoreDate/ignoreBlankStr对insert(pet)无效,有多参数的insert替代.</p>
<div class="hr"><b></b></div>
<h1><a name="如何过滤字段"></a>如何过滤字段</h1>
<div style="float:right;"><a href="#top">Top</a></div>
<p>如下代码，将只更新 Pet 的 id 和 name 属性：</p>
<pre><span class="zdoc_code_cmt">// 第二个参数是正则表达式
</span>FieldFilter ff = FieldFilter.create(Pet.class, "^id|name$");
ff.run(new Atom() {
	public void run() {
		Pet pet = dao.fetch(Pet.class, 24);
		pet.setName("ABC");
		pet.setNickname("XiaoBai");
		dao.update(pet);
	}
});
<span class="zdoc_code_cmt">// 或者
</span>Daos.ext(dao, ff).update(pet);
</pre>
<p>以下代码, 将只查询id和name属性</p>
<pre>FieldFilter ff = FieldFilter.create(Pet.class, "^id|name$");
Pet pet = ff.run(new Molecule() {
	public void run() {
		setObj(dao.fetch(Pet.class, "ABC"));
	}
});
<span class="zdoc_code_cmt">// 或者用Daos.ext
</span>Pet pet = Daos.ext(dao, ff).fetch(Pet.class, "ABC");
</pre>
<div class="hr"><b></b></div>
<h1><a name="字段过滤器的原理"></a>字段过滤器的原理</h1>
<div style="float:right;"><a href="#top">Top</a></div>
<p>字段过滤，不过是要在一个地方记录一下下面两个信息：</p>
<ol type="1">
<li>对什么实体</li>
<li>过滤哪些字段</li>
</ol>
<p>并且它希望 Nutz.Dao 自行能获取到这些信息。当然，ThreadLocal 就是一个很好的选择。实际上，你如果看看 FieldFilter 里面的方法，你其实就能猜到。为了能为多个实体保存字段过滤配置信息，它实际上在ThreadLoacal 里保存了自身的一个实例，同时，它自己有一个私有的  Map&lt;Class&lt;?&gt;, FieldMatcher&gt;，具体的，你可以看 FieldFilter 这个类的定义:</p>
<pre>public class FieldFilter {

    ...
    private static ThreadLocal&lt;FieldFilter&gt; FF = new ThreadLocal&lt;FieldFilter&gt;();
    ...
    private Map&lt;Class&lt;?&gt;, FieldMatcher&gt; map;
    ...
</pre>
<p>而且既然在 ThreadLocal 设置了数据，它就不得不考虑如何让你清除这个数据。因此，它的写法也保证了你一定会清掉你的数据了。</p>
<pre>FieldFilter ... run(new Atom(){  <span class="zdoc_code_cmt">// &lt;-- 开始将自身加入 ThreadLocal
</span>    public void run(){
        <span class="zdoc_code_cmt">// 这里是你的代码，你的 Dao 调用都会得到 ThreadLocal 中你对于实体字段过滤的设置
</span>    }
}); <span class="zdoc_code_cmt">//  &lt;-- run 方法结束前，会从 ThreadLocal 清除自身
</span></pre>
<div class="hr"><b></b></div>
<h1><a name="字段过滤器的创建"></a>字段过滤器的创建</h1>
<div style="float:right;"><a href="#top">Top</a></div>
<p>下面是一个最简单和常用的例子：</p>
<pre>FieldFilter.create(Pet.class, "^id|name$").run(new Atom(){
    public void run(){
        <span class="zdoc_code_cmt">// TODO 你的 DAO 操作代码
</span>    }
});
</pre>
<ul type="disc">
<li>这样，无论你查询或者更新等操作，对 Pet 这个实体只会针对能被正则表达式 "id|name" 匹配的字段进行操作
<ul type="circle">
<li>实际上，上例的正则表达式表示: <span style="color:#FF0000;"> 所有包括 id 和 name 字符的字段</span></li>
</ul>
</li>
<li>如果你想仅仅让 id 和 name 字段受到匹配，你的正则表达式最好写的严格一些，比如 "^id|name$"</li>
<li>当然，SQL 的条件部分不会受到字段过滤器的影响</li>
</ul>
<p>如果你读完上面的介绍，你应该就很了解字段过滤器如何使用了，但是你可能还有个几个小疑问:</p>
<ul type="disc">
<li>如果我字段比较多怎么办呢？</li>
<li>如果我想忽略所有之为空的字段怎么办呢？</li>
<li>如果我想同时为多个实体设置字段过滤怎么办呢？</li>
</ul>
<div class="hr"><b></b></div>
<h1><a name="忽略少数字段"></a>忽略少数字段</h1>
<div style="float:right;"><a href="#top">Top</a></div>
<pre>FieldFilter.locked(Pet.class, "^last|age$").run(new Atom(){
    public void run(){
        <span class="zdoc_code_cmt">// TODO 你的 DAO 操作代码
</span>    }
});
</pre>
<div class="hr"><b></b></div>
<h1><a name="忽略空值"></a>忽略空值</h1>
<div style="float:right;"><a href="#top">Top</a></div>
<pre>FieldFilter.create(Pet.class, true).run(new Atom(){
    public void run(){
        <span class="zdoc_code_cmt">// TODO 你的 DAO 操作代码
</span>    }
});
</pre>
<div class="hr"><b></b></div>
<h1><a name="保留几个字段且忽略空值"></a>保留几个字段且忽略空值</h1>
<div style="float:right;"><a href="#top">Top</a></div>
<pre>FieldFilter.create(Pet.class,"^id|name|age|last$", true).run(new Atom(){
    public void run(){
        <span class="zdoc_code_cmt">// TODO 你的 DAO 操作代码
</span>    }
});
</pre>
<div class="hr"><b></b></div>
<h1><a name="忽略少数字段且忽略空值"></a>忽略少数字段且忽略空值</h1>
<div style="float:right;"><a href="#top">Top</a></div>
<pre>FieldFilter.create(Pet.class, null, "^age|last$", true).run(new Atom(){
    public void run(){
        <span class="zdoc_code_cmt">// TODO 你的 DAO 操作代码
</span>    }
});
</pre>
<div class="hr"><b></b></div>
<h1><a name="为多个实体设置字段过滤"></a>为多个实体设置字段过滤</h1>
<div style="float:right;"><a href="#top">Top</a></div>
<pre>FieldFilter.create(Pet.class, true)
           .set(Master.class, "^id|name$")
           .run(new Atom(){
    public void run(){
        <span class="zdoc_code_cmt">// TODO 你的 DAO 操作代码
</span>    }
});
</pre>
<div class="hr"><b></b></div>
<h1><a name="使用FieldMatcher创建复杂规则"></a>使用FieldMatcher创建复杂规则</h1>
<div style="float:right;"><a href="#top">Top</a></div>
<pre>FieldMatcher fm = FieldMatcher.make(actived, locked, ignoreNull, 
                                ignoreZero, ignoreDate, 
                                ignoreId,
                                ignoreName,
                                ignorePk);
FieldFilter ff = FieldFilter.create(Pet.class, fm);
</pre>
<div class="hr"><b></b></div>
<h1><a name="无需匿名内部类的写法"></a>无需匿名内部类的写法</h1>
<div style="float:right;"><a href="#top">Top</a></div>
<p>从1.b.51开始支持不使用匿名内部类的方法, Daos.ext方法. 该方法有两个变种, 分别支持字段过滤和动态表名.</p>
<p>示例</p>
<pre><span class="zdoc_code_cmt">//原写法
</span>FieldFilter.create(Pet.class, "^id|name$").run(new Atom(){
    public void run(){
        dao.update(pet); <span class="zdoc_code_cmt">// 这里的pet必须是final
</span>    }
});
<span class="zdoc_code_cmt">// 新的写法
</span>Daos.ext(dao, FieldFilter.create(Pet.class, "^id|name$")).update(pet);
<span class="zdoc_code_cmt">// ext方法会返回一个Dao实例,是对原有dao对象的封装
</span></pre>
<p>FieldFilter实例及Daos.ext返回的Dao实例,可重复使用,均为线程安全的.</p>
</div>
<div class="zdoc_footer"><em>By:</em><b>zozoh</b><a href="mailto:zozohtnt@gmail.com">&lt;zozohtnt@gmail.com&gt;</a></div>
</body>
</html>