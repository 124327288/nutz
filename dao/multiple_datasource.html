<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head><meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=UTF-8"/>
<title>多数据源</title><link href="../zdoc.css" rel="stylesheet" type="text/css"/>
</head>
<body><a name="top"></a>
<div class="zdoc_header">多数据源</div>
<div class="zdoc_author"><em>By:</em><b>zozoh</b><a href="mailto:zozohtnt@gmail.com">&lt;zozohtnt@gmail.com&gt;</a></div>
<div class="zdoc_body">
<ul class="zdoc_index_table">
<li>
<div><span class="num">1</span><a href="#概述">概述</a></div>
</li>
<li>
<div><span class="num">2</span><a href="#配对模式在Ioc中的示例">配对模式在Ioc中的示例</a></div>
</li>
<li>
<div><span class="num">3</span><a href="#多数据源下的事务模板">多数据源下的事务模板</a></div>
</li>
</ul>
<div class="hr"><b></b></div>
<h1><a name="概述"></a>概述</h1>
<div style="float:right;"><a href="#top">Top</a></div>
<p>由于这个问题经常被问到,nutzcn社区累计了好几十个帖子,所以有必要单独开个文档描述一下</p>
<p>在一些复杂或遗留系统中,通常需要操作两个或更多的数据源.</p>
<p>总的原则: NutDao与DataSource是一对一关系. </p>
<p>值得注意的是, javax.sql.DataSource只是一个接口,而且NutDao只会调用其getConnection()方法.</p>
<div class="hr"><b></b></div>
<h1><a name="配对模式在Ioc中的示例"></a>配对模式在Ioc中的示例</h1>
<div style="float:right;"><a href="#top">Top</a></div>
<p>你可以定义无数个dataSourceXXX,只要它们使用不一样的名称, 然后建立对应的N个NutDao实例</p>
<p>每个NutDao实例,均refer对应的dataSource</p>
<pre>    <span class="zdoc_code_cmt">// 主数据库
</span>    dataSource : {
    	<span class="zdoc_code_cmt">// 按标准的写法
</span>    },
    <span class="zdoc_code_cmt">// 主Dao实例
</span>	dao : {
		type : "org.nutz.dao.impl.NutDao",
		args : [{refer:"dataSource"}] <span class="zdoc_code_cmt">//引用主数据源
</span>	},
	<span class="zdoc_code_cmt">//--------------------------------------------------------
</span>    <span class="zdoc_code_cmt">// 第三方订单数据库
</span>    dataSourceOrder : {
        <span class="zdoc_code_cmt">// 同样是标准的写法
</span>    },
	daoOrder : {
		type : "org.nutz.dao.impl.NutDao",
		args : [{refer:"dataSourceOrder"}] <span class="zdoc_code_cmt">//引用第三方数据源
</span>	},
	<span class="zdoc_code_cmt">//--------------------------------------------------------
</span>    <span class="zdoc_code_cmt">// 遗留数据库
</span>    dataSourceOld : {
        <span class="zdoc_code_cmt">// 同样是标准的写法
</span>    },
	daoOld : {
		type : "org.nutz.dao.impl.NutDao",
		args : [{refer:"dataSourceOld"}] <span class="zdoc_code_cmt">//引用第三方数据源
</span>	},
</pre>
<p>在Module/Service类中的注入</p>
<pre><span class="zdoc_code_cmt">// 非父类字段的注入
</span>@Inject
protect Dao dao; <span class="zdoc_code_cmt">// 注入主Dao实例
</span>@Inject
protect Dao daoOrder; <span class="zdoc_code_cmt">// 注入第三方订单数据库Dao实例
</span>
<span class="zdoc_code_cmt">// 通过父类字段的注入,通常是继承的EntityService的服务类.
</span>@IocBean(args={"refer:daoOrder"})
<span class="zdoc_code_cmt">// 效果是: 调用dao()返回的将是daoOrder实例.
</span></pre>
<div class="hr"><b></b></div>
<h1><a name="多数据源下的事务模板"></a>多数据源下的事务模板</h1>
<div style="float:right;"><a href="#top">Top</a></div>
<p>在一般情况下,Trans.exec下,多个数据源下的事务能正常工作,除特殊的情况: 某个数据源commit时报错,之前已经commit的数据源无法回滚.</p>
<p>假设有A,B,C三个数据源</p>
<pre>Trans.exec(new Atom(){
	public void run() {
		dao.insert(user);
		daoOrder.insert(order);
		daoOld.insert(report);
	}
});
</pre>
<p>事务执行时序</p>
<pre>begin &gt; dao
begin &gt; daoOrder
begin &gt; daoOld

commit &gt; dao
commit &gt; daoOrder
commit &gt; daoOld <span class="zdoc_code_cmt">#出错
</span>
rollback &gt; dao <span class="zdoc_code_cmt"># 回滚失败,因为已经commit过
</span>rollback &gt; daoOrder <span class="zdoc_code_cmt"># 回滚失败,因为已经commit过
</span>rollback &gt; daoOld <span class="zdoc_code_cmt"># 可能也失败,但没有提交成功
</span></pre>
<p>以上特殊情况,是任何基于标准JDBC驱动的ORM都无法回避的. 走XA的JDBC API才可能解决.</p>
</div>
<div class="zdoc_footer"><em>By:</em><b>zozoh</b><a href="mailto:zozohtnt@gmail.com">&lt;zozohtnt@gmail.com&gt;</a></div>
</body>
</html>