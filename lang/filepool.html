<html>
<head>
<title>文件池</title>
</head>
<body><a name="top"></a>
<div class="zdoc_header">文件池</div>
<div class="zdoc_author"><em>By:</em><b>zozoh</b><a href="mailto:zozohtnt@gmail.com">&lt;zozohtnt@gmail.com&gt;</a></div>
<div class="zdoc_body">
<div class="hr"><b></b></div>
<h1>什么是文件池</h1>
<p>如果大家写一些稍微复杂的应用，可能或多或少的会使用一下临时文件。或者希望能有一个目录，保存用户上传的文件。你的用法可能有下面两种：</p>
<ul type="disc">
<li>文件不能超过一定数量，超过了自动删除旧的</li>
<li>文件永远保存，除非程序主动删除</li>
</ul>
<p>对于网络应用，处理用户上传的文件，有一种比较常用的做法是：</p>
<ul type="disc">
<li>把文件的索引以及一些信息记录在数据库里</li>
<li>把文件内容记录在磁盘里</li>
</ul>
<p>而 Nutz 的文件池，就是为上述这些场景设计的。</p>
<div class="hr"><b></b></div>
<h1>怎么使用文件池</h1>
<p>对于文件池，它有一个接口 '<span style="color:#AA00AA;"><b>org.nutz.filepool.FilePool</b></span>' 以及一个简单的实现 '<span style="color:#AA00AA;"><b>org.nutz.filepool.NutFilePool</b></span>'。当然，你可以根据需要实现自己的特殊规则的文件池实现类。</p>
<h2>创建文件池</h2>
<pre><span class="zdoc_code_cmt">// 将目录 ~/tmp/myfiles 作为一个文件池的根目录，里面最多同时有2000个文件
</span>FilePool pool = new NutFilePool("~/tmp/myfiles", 2000);

<span class="zdoc_code_cmt">// 将目录 ~/tmp/myfiles 作为一个文件池的根目录，里面不限文件
</span>FilePool pool = new NutFilePool("~/tmp/myfiles");
<span class="zdoc_code_cmt">// 相当于 FilePool pool = new NutFilePool("~/tmp/myfiles", 0);
</span></pre>
<h2>在池中创建一个文件</h2>
<pre>File f = pool.createFile(".png");  <span class="zdoc_code_cmt">// 该文件本句之后，已经被创建
</span><span class="zdoc_code_cmt">// TODO 为这个文件写入内容
</span></pre>
<p>实际上， NutFilePool 会将你的 id （一个 Long 值）以及后缀变成如下形式的文件路径:</p>
<pre>~/tmp/myfiles/00/00/00/00/00/00/00/EF.png
</pre>
<p>也就是说，你传入的 Long 值会先变成字符串 '00000000000000EF'， 然后每两位字符加入一个 '/'，最后拼上 ".png" 就成为你这个文件在池中的路径了。</p>
<p>这样做的好处是，你只要在数据库记录一个自增的 ID，就能知道在池中对应文件的路径。同样，如果你知道了在池中对应文件的路径，你也能知道在数据库中记录的 ID。这个特性有时候是很有用的。</p>
<p>文件池会维护一个自增的 id， 每当成功创建一个文件后，它就会自加。</p>
<p><span style="color:#0000AA;"><b>补充说明:</b></span>NutFilePool 这个实现非常简单，没有考虑到集群，即多台主机共用一个文件池的问题。但是如果在一台主机内，虽然它没用用线程同步锁，但是线程安全也不太会是问题，因为是直接一句自加，即使是多线程竞争也不会出问题的。</p>
<p>了解了这个之后，之后的操作就都顺理成章了 ^_^</p>
<h2>从池中获取一个文件</h2>
<pre>File f = pool.getFile(239, ".png");  <span class="zdoc_code_cmt">// 如果文件不存在，将返回 null
</span></pre>
<h2>从池中获取一个文件，如果不存在，创建它</h2>
<pre>File f = pool.returnFile(239, ".png");  
</pre>
<h2>从池中删除一个文件</h2>
<pre>File f = pool.removeFile(239, ".png");
</pre>
<h2>判断池中是否存在一个文件</h2>
<pre>boolean exists = pool.hasFile(239, ".png");
</pre>
<h2>看看当前池中最大的文件 ID</h2>
<pre>long maxId = pool.current();
</pre>
<h2>看看某一个池中的文件的 ID 为多少</h2>
<pre>File f = pool.getFile(239, ".png");
long fId = pool.getFileId(f, ".png");
<span class="zdoc_code_cmt">// fId should be 239
</span></pre>
<h2>清除池中所有文件</h2>
<pre>pool.clear();
</pre>
<div class="hr"><b></b></div>
<h1>在 Ioc 中使用</h1>
<p>文件池当然可以被任何 Ioc 容器管理，下面我们以 Nutz.Ioc 的 JSON 配置方式来举例:</p>
<pre>{
    pool : {
        type : 'org.nutz.filepool.NutFilePool',
        args : ['~/tmp/files', 2000]
    }
}
</pre>
<p>我想熟悉 Spring 或者 Guice 的朋友，怎么配置自然不用我多嘴了吧 </p>
</div>
<div class="zdoc_footer"><em>By:</em><b>zozoh</b><a href="mailto:zozohtnt@gmail.com">&lt;zozohtnt@gmail.com&gt;</a></div>
</body>
</html>