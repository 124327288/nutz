<html>
<head>
<title>AOP -- 声明式切片</title>
</head>
<body><a name="top"></a>
<div class="zdoc_header">AOP -- 声明式切片</div>
<div class="zdoc_author"><em>By:</em><b>wendal</b><a href="mailto:wendal1985@gmail.com">&lt;wendal1985@gmail.com&gt;</a></div>
<div class="zdoc_body">
<div class="hr"><b></b></div>
<h1>单纯的AOP</h1>
<h2>创建一个拦截器类,在方法执行前后打印一句日志</h2>
<pre>package aop;
import org.nutz.aop.ClassAgent;
import org.nutz.aop.ClassDefiner;
import org.nutz.aop.DefaultClassDefiner;
import org.nutz.aop.InterceptorChain;
import org.nutz.aop.MethodInterceptor;
import org.nutz.aop.asm.AsmClassAgent;
import org.nutz.aop.matcher.MethodMatcherFactory;

public class UserAction { <span class="zdoc_code_cmt">//被AOP的类,必须是public的非abstract类!
</span>    
    public boolean login(String username, String password) throws Throwable {
        if ("wendal".equals(username) &amp;&amp; "qazwsxedc".equals(password)) {
            System.out.println("登陆成功");
            return true;
        }
        System.out.println("登陆失败");
        return false;
    }

    private static ClassDefiner cd = new DefaultClassDefiner(UserAction.class.getClassLoader());
    
    public static void main(String[] args) throws Throwable {
        <span class="zdoc_code_cmt">//无AOP的时候
</span>        UserAction ua = new UserAction(); <span class="zdoc_code_cmt">//直接new,将按原本的流程执行
</span>        ua.login("wendal", "qazwsxedc");

        System.out.println("-----------------------------------------------------");
        System.out.println("-----------------------------------------------------");
        
        <span class="zdoc_code_cmt">//有AOP的时候
</span>        ClassAgent agent = new AsmClassAgent();
        LogInterceptor log = new LogInterceptor();
        agent.addInterceptor(MethodMatcherFactory.matcher("^login$"), log);
        <span class="zdoc_code_cmt">//返回被AOP改造的Class实例
</span>        Class&lt;? extends UserAction&gt; userAction2 = agent.define(cd, UserAction.class);
        UserAction action = userAction2.newInstance();
        action.login("wendal", "qazwsxedc");<span class="zdoc_code_cmt">//通过日志,可以看到方法执行前后有额外的日志
</span>    }
}

class LogInterceptor implements MethodInterceptor {
    public void filter(InterceptorChain chain) throws Throwable {
        System.out.println("方法即将执行 --&gt;" + chain.getCallingMethod());
        chain.doChain();<span class="zdoc_code_cmt">// 继续执行其他拦截器
</span>        System.out.println("方法执行完毕 --&gt;" + chain.getCallingMethod());
    }
}
</pre>
<h2>输出</h2>
<pre>登陆成功
-----------------------------------------------------
-----------------------------------------------------
方法即将执行 --&gt;public boolean aop.UserAction.login(java.lang.String,java.lang.String) throws java.lang.Throwable
登陆成功
方法执行完毕 --&gt;public boolean aop.UserAction.login(java.lang.String,java.lang.String) throws java.lang.Throwable
</pre>
<div class="hr"><b></b></div>
<h1>在Ioc中使用Aop</h1>
<h2>声明拦截器</h2>
<ul type="disc">
<li>你需要有一个拦截器对象，如果你愿意，你当然可以有不止一个拦截器对象。</li>
<li>将这个对象声明在你的Ioc配置文件里，就像一个普通的对象一样</li>
</ul>
<h2>在对象的方法中声明切片</h2>
<ul type="disc">
<li>在你要拦截的方法上，声明 @Aop 注解或者其他配置形式,如js/xml</li>
<li>@Aop 注解接受数目可变的字符串，每个字符串都是一个拦截器的名称,即必须在ioc中声明这个拦截器</li>
<li>方法所在的对象必须是Ioc容器中的对象</li>
</ul>
<h2>将上一个例子,改造为Ioc形式</h2>
<pre>package aop;
import org.nutz.ioc.aop.Aop;
import org.nutz.ioc.loader.annotation.IocBean;

import org.nutz.ioc.loader.annotation.AnnotationIocLoader;
import org.nutz.ioc.Ioc;
import org.nutz.ioc.impl.NutIoc;

@IocBean
public class UserAction { <span class="zdoc_code_cmt">//被AOP的类,必须是public的非abstract类!
</span>    
    @Aop({"logInterceptor"}) <span class="zdoc_code_cmt">//这里写拦截器bean的名字
</span>    public boolean login(String username, String password) throws Throwable {
        if ("wendal".equals(username) &amp;&amp; "qazwsxedc".equals(password)) {
            System.out.println("登陆成功");
            return true;
        }
        System.out.println("登陆失败");
        return false;
    }
    
    public static void main(String[] args) throws Throwable {
    	Ioc ioc = new NutIoc(new AnnotationIocLoader("aop"));
    	UserAction action = ioc.get(UserAction.class);
    	action.login("wendal", "qazwsxedc");
    }
}
<span class="zdoc_code_cmt">//另外一个类文件
</span>package aop;
import org.nutz.ioc.loader.annotation.IocBean;
import org.nutz.aop.InterceptorChain;
import org.nutz.aop.MethodInterceptor;

@IocBean <span class="zdoc_code_cmt">//声明为一个Ioc的bean,名字为logInterceptor
</span>public class LogInterceptor implements MethodInterceptor {
    public void filter(InterceptorChain chain) throws Throwable {
        System.out.println("方法即将执行 --&gt;" + chain.getCallingMethod());
        chain.doChain();<span class="zdoc_code_cmt">// 继续执行其他拦截器
</span>        System.out.println("方法执行完毕 --&gt;" + chain.getCallingMethod());
    }
}
</pre>
<div class="hr"><b></b></div>
<h1>已经为你准备好的拦截器</h1>
<ul type="disc">
<li>org.nutz.aop.interceptor.LoggingMethodInterceptor 添加日志记录</li>
<li>org.nutz.aop.interceptor.TransactionInterceptor 添加数据库事务(用于NutDao)</li>
</ul>
</div>
<div class="zdoc_footer"><em>By:</em><b>wendal</b><a href="mailto:wendal1985@gmail.com">&lt;wendal1985@gmail.com&gt;</a></div>
</body>
</html>