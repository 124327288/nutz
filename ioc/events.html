<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html>
<head><meta HTTP-EQUIV="Content-Type" CONTENT="text/html; charset=UTF-8"/>
<title>事件监听</title><link href="../zdoc.css" rel="stylesheet" type="text/css"/>
</head>
<body><a name="top"></a>
<div class="zdoc_header">事件监听</div>
<div class="zdoc_author"><em>By:</em><b>zozoh</b><a href="mailto:zozohtnt@gmail.com">&lt;zozohtnt@gmail.com&gt;</a></div>
<div class="zdoc_body">
<ul class="zdoc_index_table">
<li>
<div><span class="num">1</span><a href="#都有哪些事件">都有哪些事件</a></div>
</li>
<li>
<div class="zdoc_folder"><span class="num">2</span><a href="#怎么监听">怎么监听</a></div>
<ul>
<li>
<div><span class="num">2.1</span><a href="#通过对象自身的一个函数">通过对象自身的一个函数</a></div>
</li>
</ul>
</li>
<li>
<div><span class="num">3</span><a href="#ioc_json文件下的配置">ioc json文件下的配置</a></div>
</li>
</ul>
<div class="hr"><b></b></div>
<h1><a name="都有哪些事件"></a>都有哪些事件</h1>
<div style="float:right;"><a href="#top">Top</a></div>
<p>Nutz.Ioc 容器有三种事件：</p>
<ul type="disc">
<li>对象被创建(create事件)</li>
<li>对象被从容器中取出(fetch事件)</li>
<li>对象被销毁(depose事件)</li>
</ul>
<p>在这三种时刻，你如果想做一些特殊的操作，比如，当一个数据源被销毁时，你希望能够关闭所有的连接，声明一下，你想监听什么事件，以及怎么监听。</p>
<p><span style="color:#FF0000;"><b> 注:</b></span> 如果你的对象是 "singleton: false"，那么容器创建了对象后就会立即忘记它的存在。因为鬼才知道你打算创建多少份该对象的实例，要是每份实例都记录的话，内存说不定爆了。所以这样的非单例对象，你在 depose 容器的时候，容器是不会调用它的 depose 方法的，即使你在配置文件中声明了它，因为容器根本就不会知道这样的对象曾经存在过。但是 create, fetch 事件还是会被调用到的。</p>
<div class="hr"><b></b></div>
<h1><a name="怎么监听"></a>怎么监听</h1>
<div style="float:right;"><a href="#top">Top</a></div>
<h2><a name="通过对象自身的一个函数"></a>通过对象自身的一个函数</h2>
<div style="float:right;"><a href="#top">Top</a></div>
<p>这个函数必须为  public，并且不能有参数</p>
<h3><a name="为_UserService_对象增加一个函数："></a>为 UserService 对象增加一个函数：</h3>
<div style="float:right;"><a href="#top">Top</a></div>
<pre>public void init() {
	init_sysuser();
	init_cmsuser();
	init_roles();
	log.debug("sysuer/cmsuser/roles init complete");
}
</pre>
<h3><a name="在_UserService_配置文件中增加新的对象"></a>在 UserService 配置文件中增加新的对象</h3>
<div style="float:right;"><a href="#top">Top</a></div>
<pre>@IocBean(create="init")
public class UserService {

...
}
</pre>
<h3><a name="调用代码,或第一次被取出时"></a>调用代码,或第一次被取出时</h3>
<div style="float:right;"><a href="#top">Top</a></div>
<pre>ioc.get(UserService.class);
</pre>
<h3><a name="控制台输出"></a>控制台输出</h3>
<div style="float:right;"><a href="#top">Top</a></div>
<pre>2016-12-15 DEBUG UserService(UserService.java:1024) : sysuer/cmsuser/roles init complete
</pre>
<div class="hr"><b></b></div>
<h1><a name="ioc_json文件下的配置"></a>ioc json文件下的配置</h1>
<div style="float:right;"><a href="#top">Top</a></div>
<pre>xyz :{
	type : "xxx.yyy.zzz.XYZ",
	events : {
		create : ... , <span class="zdoc_code_cmt">// 创建完成后,各种属性已经设置好
</span>		fetch  : ... , <span class="zdoc_code_cmt">// 每次从ioc取出
</span>		depose : ...   <span class="zdoc_code_cmt">// ioc容器销毁前,一般用于清理各种资源
</span>	}
}
</pre>
<p>根据需要，你可以选择上述三个事件，为其声明触发器，或者触发函数。</p>
<p>切勿用ioc js和@IocBean同时定义一个bean,这样的话,只有一个会生效</p>
</div>
<div class="zdoc_footer"><em>By:</em><b>zozoh</b><a href="mailto:zozohtnt@gmail.com">&lt;zozohtnt@gmail.com&gt;</a></div>
</body>
</html>